# 面向对象

> 组成员：[方茂](https://user.qzone.qq.com/1906372840)、[胡锦辉](https://user.qzone.qq.com/2783623013)、[黄子扬](https://user.qzone.qq.com/3086116929)、[王蕊](https://user.qzone.qq.com/3495582261)、[吴师警](https://user.qzone.qq.com/1677149442)



## 01.基本概念

#### 1.1 基本定义

**面向对象**就是相对与**面向过程**的另一种*编程方法*
其中：

- **过程** 是早期的一个编程概念
- **过程** 类似于函数，只能执行，但是没有返回值
- **函数** 不仅能执行，还可以返回结果

#### 1.2 优缺点

**面向对象**：

- 优点：
  - **可重用性（Reusability）**：通过类和对象的概念，可以更容易地重用代码，因为可以创建可重用的类。
  - **可维护性（Maintainability）**：封装性和抽象性使得代码更易于维护，因为更改类内部不会影响其他部分。
  - **扩展性（Extensibility）**：继承和多态性允许程序员创建更多功能而无需修改现有代码。
  - **可靠性（Reliability）**：封装性和隐藏性减少了不必要的依赖，使得代码更可靠。

- 缺点：
  - **复杂性（Complexity）**：面向对象编程可能会导致更多的抽象和层次，从而增加了学习和理解的难度。
  - **性能（Performance）**：相对于面向过程编程，在某些情况下可能会有一些性能上的损失，尤其是在大量对象和继承层次较深的情况下。
  - **学习曲线（Learning Curve）**：对于初学者来说，理解面向对象编程的概念可能需要更多的时间和经验。

**面向过程**：

- 优点：
  - **简单性（Simplicity）**：面向过程的代码通常更直接和易于理解，因为它按照顺序执行操作。
  - **性能（Performance）**：在某些情况下，面向过程的代码可能比面向对象的代码更高效。
  - **适合小规模项目（Suitable for Small Projects）**：对于简单和小规模的任务，面向过程编程可能更容易上手。

- 缺点：
  - **可维护性和扩展性差（Poor Maintainability and Extensibility）**：随着项目规模的扩大，面向过程的代码往往难以维护和扩展。
  - **代码复用性差（Poor Reusability）**：代码重用性有限，因为功能往往是直接编写在程序的各个部分中。

#### 1.3 面向对象编程的基本原则

- **抽象（Abstraction）**：将现实世界中的实体抽象为程序中的类或对象，强调对象的属性和行为。
- **封装（Encapsulation）**：将数据和代码封装在类中，控制外部访问对象的方式，隐藏对象的内部细节。
- **继承（Inheritance）**：子类可以继承父类的属性和方法，有助于代码的重用和扩展。
- **多态（Polymorphism）**：不同类的对象可以对相同的方法做出不同的响应，提高了代码的灵活性和可扩展性。

## 02.类和对象

#### 2.1 类

- **类** 是是对一群具有 **相同 特征** 或者 **行为** 的事物的一个统称，是抽象的，**不能直接使用**

- **类** 是一种 **预定义**

- 有 **类属性**  和  **类方法**

  ```python
  class dogs(object):
      def __init__(self): #<--- （像带有双下划线的为python特有的魔法函数）
          legs = 4		#__init__可以用来继承和赋予类属性
          mouth = 1
      #这两个是类属性
      def talk(self):
          print("wolf")
          #这个是类方法
  
  XiaoHuang = dogs() #创造实例，类不能直接使用
  print(XiaoHuang.legs, '/n',XiaoHuang.mouth)
  XiaoHuang.talk()
  -------------------------------------------------
  >>>4
  >>>1
  >>>wolf
  ```

  

#### 2.2 对象

- **对象** 不是固定的，是在**面向对象**编程中根据**需要**而分解出的具有**特定功能**的部分

- 由**哪一个类**创建出来的**对象**，就拥有在**哪一个类**中定义的：
  - 属性
  - 方法
#### 2.3 实例
- **实例** 是以 *类* 为模板 “刻” 出来的实际对象

- **实例** 继承了母类的所有**特征**和**方法**

#### 2.3 科普（python里的命名习惯）

- 定义类名时，应当使用驼峰式大小写分隔单词，并且类名应当尽量是名词以描述类的类型和特性。
- 定义模块和包名时，应当使用全小写字母，可以使用下划线假想空格，并且模块名应该是描述模块功能的单词或者短语，而包名应当使用描述包的内容或用途的名词。
- 使用双下划线开头结尾的名称是Python的魔术方法，这类格式的名称不应该出现在任何变量名称中。



## 03.类的基础语法

#### 3.1 类的基本结构

在Python中，定义类使用关键字 `class`。

```python
class MyClass:
    # 类的属性
    variable = "这是一个类的属性"

    # 类的方法
    def my_method(self):
        print("这是一个类的方法")
```

#### 3.2 实例化类

通过类创建对象的过程称为实例化。可以通过类名后加括号的方式来实例化一个类，创建一个对象（也称为类的实例）：

```python
pythonCopy code# 创建 MyClass 类的实例
obj = MyClass()
```

#### 3.3 访问类的属性和方法

```python
# 访问类的属性
print(obj.variable)  # 输出：这是一个类的属性

# 调用类的方法
obj.my_method()  # 输出：这是一个类的方法
```

#### 3.4 初始化方法 `__init__()`

`__init__()` 是一个特殊的方法，在创建类的实例时被调用，用于初始化对象的属性。它接受参数并将它们分配给对象的属性。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建 Person 类的实例并初始化属性
person = Person("张三", 25)
```

#### 3.5 `__str__()` 方法

`__str__()` 方法用于返回对象的字符串表示。当使用 `print()` 函数输出对象时，会自动调用这个方法。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"姓名：{self.name}, 年龄：{self.age}"

# 创建 Person 类的实例并使用 __str__() 方法
person = Person("张三", 25)
print(person)  # 输出：姓名：张三, 年龄：25
```

#### 3.6 `__del__()` 方法

`__del__()` 方法用于在对象被销毁（即内存被回收）前执行一些清理工作。它在对象被垃圾回收时被调用。

```python
class MyClass:
    def __del__(self):
        print("对象被销毁")

# 创建 MyClass 类的实例并在程序结束时销毁
obj = MyClass()
# 在程序结束时会输出：对象被销毁
```

#### *3.7 私有函数和方法

- 在实际开发中，**对象** 的 **某些属性或方法** 可能只希望 **在对象的内部被使用**，而 **不希望在外部被访问到**
- **私有属性** 就是 **对象** 不希望公开的 **属性**
- **私有方法** 就是 **对象** 不希望公开的 **方法**

**定义方式**

- 在 **定义属性或方法时**，在 **属性名或者方法名前** 增加 **两个下划线**，定义的就是 **私有** 属性或方法



```python
class Women:

    def __init__(self, name):

        self.name = name
        # 不要问女生的年龄
        self.__age = 18

    def __secret(self):
        print("我的年龄是 %d" % self.__age)


xiaofang = Women("小芳")
# 私有属性，外部不能直接访问
# print(xiaofang.__age)

# 私有方法，外部不能直接调用
# xiaofang.__secret()
```

-  **伪私有属性和私有方法（科普）**

> 提示：在日常开发中，**不要使用这种方式**，**访问对象的 私有属性 或 私有方法**

`Python` 中，并没有 **真正意义** 的 **私有**

- 在给 **属性**、**方法** 命名时，实际是对 **名称** 做了一些特殊处理，使得外界无法访问到
- **处理方式**：在 **名称** 前面加上 `_类名` => `_类名__名称`

```python
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()
```

当涉及到继承时，Python允许子类继承父类的属性和方法。以下是关于继承的内容：

## 04 继承

#### 4.0 继承的概念

在Python中，**继承**是指一个**类**（子类）可以继承另一个**类**（父类）的**属性**和方法。子类**可以使用父类的所有属性和方法**，并且可以根据需要**添加新的属性和方法**或者**重写父类的方法**。

#### 4.1：继承示例

##### 示例 1：简单的继承

```python
# 父类
class Animal:
    def sound(self):
        print("动物发出声音")

# 子类
class Dog(Animal):
    def bark(self):
        print("狗在汪汪叫")

# 创建 Dog 类的实例并调用继承的方法
dog = Dog()
dog.sound()  # 输出：动物发出声音
dog.bark()   # 输出：狗在汪汪叫
```

在这个例子中，`Dog` 类继承了 `Animal` 类的 `sound()` 方法，并添加了自己的 `bark()` 方法。

##### 示例 2：方法的重写

```python
# 父类
class Animal:
    def sound(self):
        print("动物发出声音")

# 子类
class Cat(Animal):
    def sound(self):  # 重写父类的方法
        print("猫在喵喵叫")

# 创建 Cat 类的实例并调用继承的方法
cat = Cat()
cat.sound()  # 输出：猫在喵喵叫
```

在这个例子中，`Cat` 类继承了 `Animal` 类的 `sound()` 方法，并对其进行了重写，改变了方法的行为。

#### 4.2 继承的语句知识点详解

- **基本继承语法**

  ```python
  class ChildClassName(ParentClassName):
      # 子类的内容
      pass
  ```

- **调用父类方法**

  在子类中可以通过 `super().method_name()` 来调用父类的方法。

  ```python
  class ChildClassName(ParentClassName):
      def some_method(self):
          super().method_name()  # 调用父类的方法
          # 其他子类的操作
  ```

- **方法的重写**

  子类可以重写父类的方法，从而改变方法的行为，但方法名和参数列表应保持一致。

  ```python
  class ParentClass:
      def some_method(self):
          print("父类方法")

  class ChildClass(ParentClass):
      def some_method(self):
          print("子类方法")  # 重写了父类的方法
  ```

- **多重继承**

  Python允许类继承多个父类，可以在类定义时将多个父类以逗号分隔列出。

  ```python
  class ChildClassName(ParentClass1, ParentClass2):
      # 子类的内容
      pass
  ```

理解多态的概念是至关重要的，这里将进一步优化对多态的描述，加入更多细节和解释。

## 05. 多态性

在面向对象编程中，多态性是一个重要概念，指的是不同类的对象对相同的方法名做出不同的响应。多态性使得可以在不同的对象上调用相同的方法，但根据对象的类型执行不同的操作。

#### 5.1 多态性的本质

多态性是面向对象编程的一个基本原则之一，它能够提高代码的灵活性和可维护性。其本质是在运行时动态确定调用的方法，而不是在编写代码时确定。这样的特性使得程序更容易扩展和维护，因为可以轻松地添加新的类并且保持现有代码的兼容性。

#### 5.2 多态性的实现方式

多态性实现的关键在于继承和方法重写（覆盖）。当一个子类继承自父类并且重写了父类的方法时，通过父类引用指向子类对象时，便可根据实际对象的类型来调用相应的方法，这就是多态性的体现。

#### 5.3 多态性的优势

- **灵活性（Flexibility）**：可以更轻松地改变或扩展程序的行为，通过简单地增加新的类和方法实现不同的行为。
- **可维护性（Maintainability）**：由于多态性可以减少代码的耦合性，使得代码更易于维护和修改。
- **可扩展性（Extensibility）**：允许在不改变现有代码的情况下引入新的类和方法，从而增强程序的功能。

#### 5.4 多态性的应用场景

多态性常见于面向对象编程中的实际场景，例如图形界面应用中的各种组件（按钮、文本框等）都具有共同的事件响应方法（比如点击），但每个组件根据其类型会有不同的具体实现。

#### 5.5 多态性的代码示例

```python
class Animal:
    def sound(self):
        print("动物发出声音")

class Dog(Animal):
    def sound(self):
        print("狗在汪汪叫")

class Cat(Animal):
    def sound(self):
        print("猫在喵喵叫")

# 多态性示例
def make_sound(animal):
    animal.sound()  # 调用相同的方法名，但根据实际对象的类型调用不同的方法

# 创建不同类的对象
dog = Dog()
cat = Cat()
generic_animal = Animal()

# 调用多态方法
make_sound(dog)  # 输出：狗在汪汪叫
make_sound(cat)  # 输出：猫在喵喵叫
make_sound(generic_animal)  # 输出：动物发出声音
```

以上示例展示了多态性的应用。在 `make_sound()` 函数中，根据传入的对象类型调用相应的 `sound()` 方法，即使方法名相同，但根据实际对象类型执行了不同的方法。

#### 5.6 多态性的思考

多态性是面向对象编程中的一个强大特性，它允许代码更具弹性和可扩展性。理解多态性有助于写出更灵活、可维护的代码，并且更好地利用面向对象编程的特性。
